import random
import numpy as np

class Gon:
    def __init__(self):
        self.animal=[['A' for i in range(50)] for j in range(50)]
        self.hunter=[['A' for i in range(50)] for j in range(50)]
        self.cave=[['A' for i in range(50)] for j in range(50)]
        self.kb=[['A' for i in range(50)] for j in range(50)]
        self.moves=[]
        self.move=1
        self.tb=False
        self.move_stack=[]
        self.unsafe=[]
        self.border=False
        self.prev=[]
        self.f=False
        self.exp_t=False
        self.visited=[]
        self.a=False
        self.right_border=False
        self.left_border=False
        self.last_move='null'
        self.step_back=False
        self.counter=0
        
    def choose('BFS', 'DFS'):
        print('Choose BFS or DFS: ')

    def get_action(self):
        actions = ['MOVE_UP', 'MOVE_DOWN', 'MOVE_LEFT', 'MOVE_RIGHT']
        
        if self.step_back==True:
            self.step_back=False
            return self.last_move

        if self.f==False:
            if self.exp_t==True:
                #self.unsafe=[
                self.exp_t=False
                self.f=True
            else:
                return(self.explore_world())

        if self.f==True:
            t=self.make_move()
            self.f=False
            return t

    def explore_world(self):
        actions = ['MOVE_UP', 'MOVE_DOWN', 'MOVE_LEFT', 'MOVE_RIGHT']
        if self.move==1 and self.tb==False:
            self.tb=True
            self.moves.append(actions[0])
            self.move_p=actions[0]
            return actions[0]
        if self.move==1 and self.tb==True:
            self.tb=False
            self.move=2
            if self.border==False:
                return actions[1]
            else:
                return actions[0]

        if self.move==2 and self.tb==False:
            self.tb=True
            self.moves.append(actions[1])
            self.move_p=actions[1]
            return actions[1]
        if self.move==2 and self.tb==True:
            self.tb=False
            self.move=3
            if self.border==False:
                return actions[0]
            else:
                return actions[1]

        if self.move==3 and self.tb==False:
            self.tb=True
            self.moves.append(actions[2])
            self.move_p=actions[2]
            return actions[2]
        if self.move==3 and self.tb==True:
            self.tb=False
            self.move=4
            if self.border==False:
                return actions[3]
            else:
                return actions[2]

        if self.move==4 and self.tb==False:
            self.tb=True
            self.moves.append(actions[3])
            self.move_p=actions[3]
            return actions[3]
        if self.move==4 and self.tb==True:
            self.tb=False
            self.move=1
            self.moves=[]
            self.exp_t=True
            if self.border==False:
                return actions[2]
            else:
                return actions[3]


    def make_move(self):
        self.f=False
        actions = ['MOVE_UP', 'MOVE_DOWN', 'MOVE_LEFT', 'MOVE_RIGHT']
        temp=[]
        t=self.check_pit(self.prev)
        if isinstance(t,int):
            if actions[t] in self.unsafe:
                if len(self.unsafe)!=1:
                    for item in self.unsafe:
                        if item==actions[t]:
                            self.unsafe.remove(item)
        for item in actions:
            if item not in self.unsafe:
                temp.append(item)
        self.unsafe=[]
        self.a=True
        if temp:
            return (random.choice(temp))

    def give_senses(self, location, breeze, stench):
        actions = ['MOVE_UP', 'MOVE_DOWN', 'MOVE_LEFT', 'MOVE_RIGHT']
        x=location[0]
        y=location[1]
        if growl==True:
            self.kb[x][y]='b'
            self.animal
        if footprint==True:
            self.kb[x][y]='b'
            self.cave
        if nen==True:
            self.kb[x][y]='b'
            self.hunter
        if growl==False and footprint==False and nen==False:
            self.kb[x][y]='o'                      
        if self.prev==location:
            self.border=True
        else:
            self.prev=location
            self.border=False
        if (breeze==True):
            self.unsafe.append(self.move_p)
        if stench==True:
            if self.arrow_fired==False:
                self.unsafe.append(self.move_p)
        c=self.killed_wumpus()
        if c in extras:
            self.shoot=c
        #input()
        #print (np.matrix(self.kb[-1::-1]))


    def locate_pit(self,location):


        x=location[0]
        y=location[1]
        if self.kb[x+2][y]=='b' and self.kb[x+1][y+1]=='b':
            self.kb[x+1][y]='p'
        if self.kb[x+2][y]=='b' and self.kb[x+1][y-1]=='b':
            self.kb[x+1][y]='p'
        if self.kb[x-2][y]=='b' and self.kb[x-1][y+1]=='b':
            self.kb[x-1][y]='p'
        if self.kb[x-2][y]=='b' and self.kb[x-1][y-1]=='b':
            self.kb[x+1][y]='p'
        if self.kb[x][y+2]=='b' and self.kb[x+1][y+1]=='b':
            self.kb[x][y+1]='p'
        if self.kb[x][y+2]=='b' and self.kb[x-1][y+1]=='b':
            self.kb[x][y+1]='p'
        if self.kb[x][y-2]=='b' and self.kb[x+1][y-1]=='b':
            self.kb[x][y-1]='p'
        if self.kb[x][y-2]=='b' and self.kb[x-1][y-1]=='b':
            self.kb[x][y-1]='p'


    def check_pit(self,l):
        x=l[0]
        y=l[1]
        if self.kb[x+1][y]=='p':
            return 3
        if self.kb[x-1][y]=='p':
            return 2
        if self.kb[x][y+1]=='p':
            return 0
        if self.kb[x][y-1]=='p':
            return 1 
